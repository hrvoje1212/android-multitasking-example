\documentclass[times, utf8, zavrsni]{fer}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{color}
\usepackage{cite}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

% TODO: Navedite broj rada.
\thesisnumber{012}

% TODO: Navedite naslov rada.
\title{Višezadaćni rad, sinkronizacijski mehanizmi i upravljanje spremnikom u Android okruženju}

% TODO: Navedite vaše ime i prezime.
\author{Hrvoje Kozak}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
% \izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}
\paragraph{}
Radni spremnik ili radna memorija \textit{(engl. Random-Access Memory, RAM)} jako je dragocjeni resurs u svakoj grani izgradnje programske podrške, a pogotovo na operacijskim sustavima na prijenosnim uređajima, gdje fizičke memorije često nedostaje. Iako nam u Android okruženju virtualni stroj Dalvik pomaže svojim rutinskim poslovima prikupljanja otpada \textit{(engl. garbage collection, GC)}, i dalje se mora jako puno paziti kada i gdje u aplikaciji otpuštamo zauzetu memoriju.\\

Cilj ovog rada je upoznati se s Android radnim okruženjem i alatima koje nam nudi za lakše upravljanje memorijom, dretvama i procesima, te izdvojiti najveće greške (npr. curenje memorije) i najbolje prakse u korištenju istih. Isto tako, pokazat će se kako svijesno možemo smanjiti potrošnju memorije kod izrade Android aplikacije\\

Rad je podijeljen u tri dijela. Prvi dio opisuje uporabu memorije iz dvije perspektive - prvo se proučava kako Android operacijski sustav upravlja memorijom, a zatim kako razvijatelj programske podrške \textit{(engl. developer)} svojim odlukama utječe na memoriju. U okviru prvog djela opisat će se praktični dio izvedbe straničenja. Drugi dio rada obrađuje procese i dretve, te njihovo korištenje s kraćim primjerima. Na kraju, u trećem djelu, navesti će se i opisati sinkronizacijski mehanizmi dretva i procesa, nakon čega će se opisati izvedba praktičnog djela Dekkerovog i Lamportovog algoritma na Android okruženju.\\

\chapter{Upravljanje memorijom}
\section{Kako operacijski sustav Android upravlja memorijom}
\paragraph{}
Android ne nudi prostor za zamjenu \textit{(engl. swap)} za memoriju. Takav prostor dio je tvrdog diska gdje se privremeno čuvaju stranice iz memorije koje su trenutno neaktivne. U tu svrhu koristi se straničenje \textit{(engl. paginig)} i mapiranje memorije \textit{(engl. memory-mapping)}.\\

\textbf{Straničenje} \textit{(engl. paging)} je način na koji se spremaju i dohvaćaju podaci s vanjskog spremnika u glavnu memoriju. Operacijski sustav dohvaća podatke u blokovima iste veličine i jedan takav blok zove se stranica. Ova tehnika, isto tako, važan je dio u ostvarenju virtualne memorije, gdje se onda korištenjem vanjskog spremnika omogućava programima da prerastu dostupnu fizičku memoriju.\\

\textbf{Datoteka mapirane memorije} \textit{(engl. Memory-mapped file)} je segment virtualne memorije kojem se dodjeljuje direktna bajt po bajt korelacija s nekom datotekom ili sličnim resursom. Tipično je to datoteka koja se nalazi fizički na disku, ali može biti i uređaj ili objekt dijeljene memorije. Nakon povezanog mapiranja između datoteke i virtualne memorije aplikaciji se omogućava da tretira mapirani dio kao primarnu memoriju.\\

To bi značilo da kada god se koristi memorija, bilo zauzimanjem novih objekata ili korištenjem mapiranih stranica, ona ostaje unutar radne memorije i ne sprema se na vanjsku stranicu. Stoga, jedini način da se kompletno otpusti memorija iz aplikacije je otpuštanje referenci na objekte koji su trenutno u memoriji, nakon čega će ta memorija biti počišćena u procesu prikupljanja otpada. Postoji jedna iznimka, datoteke mapirane u sustav koje nisu mijenjane (npr. izvorni kod) mogu se izvaditi u stranicu izvan radne memorije ako sustav trenutno želi koristiti tu memoriju u druge svrhe.

\subsection{Dijeljenje memorije}
\paragraph{}
Kako bi uspjeli ubaciti sve u memoriju što nam je potrebno, procesi su primorani dijeliti stranice radnog spremnika. Samo dijeljenje stranica između procesa događa se na sljedeći način:

\begin{enumerate}
\item
Svaki proces aplikacije se račva \textit{(engl. fork)} od glavnog postojećeg procesa zvanog Zigota. Proces Zigote započinje svoj život odmah nakon što se uređaj pokrene \textit{(engl. boot)} i učita izvorni kod radnog okruženja \textit{(engl. framework)} i resurse. Prilikom pokretanja novog procesa aplikacije, sustav račva Zigotu, te učita i pokrene izvorni kod aplikacije u novom procesu. Time se dobiva efekt da većina stranica zauzetih u memoriji za radno okruženje i resurse bude dijeljena na svim živim procesima.

\item
Većina statičnih podataka je mapirano u proces. Na taj su način ti podaci automatski podijeljeni s drugim procesima i mogu se zapisati u stranice ako je potrebno.

\item
Na puno mjesta, Android dijeli isti dinamički radni spremnik na više procesa pomoću eksplicitno zauzete regije djeljene memorije (korištenjem \textit{ashmem} ili \textit{gralloc} naredbi).
\end{enumerate}

\subsection{Zauzimanje i oslobađanje memorije}
\paragraph{}
Za svaki proces, hrpa virtualnog stroja Dalvik limitirana je na samo jednu virtualnu memoriju. To određuje logičku veličinu hrpe, koja raste po potrebi i koja ne mora nužno biti jednaka količini fizičke memorije koju hrpa koristi. Dalvik hrpa ne sažima logičku veličinu hrpe, što znači da ne radi nikakvu fragmentaciju. Jedino u slučaju pojavljivanja neiskorištenog prostora na kraju hrpe operacijski sustav može sažeti logičku veličinu hrpe.\\

Što se tiče fizičke memorije koju koristi hrpa, ona se može smanjiti. Nakon prikupljanja smeća, virtualni stroj Dalvik prolazi kroz hrpu i nalazi nekorištene stranice koje onda vraća nazad \textit{kernelu} (naredbom \textit{madvise}). Treba primijetiti da ako imamo zauzimanje upareno s oslobađanjem, kod velikih komada memorije može se očekivati da će sva memorija biti vraćena. S druge strane manje efektivan je slučaj kada se promatraju manja zauzimanja memorije jer stranica korištena za manja zauzeća može biti dijeljena s nečime što se još nije oslobodilo.

\subsection{Ograničavanje memorije aplikacije}
\paragraph{}
Kako bi održao funkcionalno višedretveno \textit{(engl. multithreading)} okruženje, Android svakoj aplikaciji postavlja limit na njezinu veličinu hrpe. Taj limit varira i ovisi o samom uređaju, a baziran je na ukupnoj količini radne memorije na uređaju. U slučaju da aplikacija pokuša zauzeti memoriju u trenutku kada je već dosegla svoj limit, dobiti će grešku \textit{OutOfMemoryError}.\\

Za provjeru slobodnog prostora na hrpi može se pozvati metoda \textit{getMemoryClass()}. Ona vraća \textit{integer} koji pokazuje količinu slobodnih megabajta na hrpi za našu aplikaciju.

\subsection{Mijenjanje aplikacije od strane korisnika}
\paragraph{}
Android nema prostor za zamjenu i iz tog razloga, kada se korisnik prebacuje iz jedne aplikacije u drugu, Android sprema trenutno nevidljive procese u LRU \textit{(engl. Least Recently Used)} priručnu memoriju \textit{(engl. cache)}. Znači da nakon što korisnik napusti aplikaciju, proces se ne ubija nego se sprema u priručnu memoriju sa svrhom ponovnog korištenja i bržih promjena aplikacija na uređaju.\\

Naravno dok se aplikacija ne koristi, pošto je spremljena u priručnoj memoriji, ona još uvijek koristi memorijski prostor. Ako sustavu nedostaje memorije, može odlučiti ubiti jednu od aplikacija u priručnoj memoriji. Odluku donosi na temelju procjene koja je aplikacija najmanje korištena u posljednje vrijeme, ili  koja od njih agresivno konzumira memoriju.

\section{Straničenje - praktični dio}
\paragraph{}
U okviru praktičnog rada dan je prikaz simulacije rada straničenja uz FIFO strategiju izbacivanja stranica. Korisnik unosi proizvoljan broj okvira za stranice u radnom spremniku i broj zahtjeva. Program nakon toga generira zahtjeve za stranicama te prikazuje povijest spremnika na ekranu u \textit{TextView}.\newpage

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}[
    basicstyle=\footnotesize , %or \small or \footnotesize etc.
]
    @OnClick(R.id.fab) public void startPagingExample(View fab) {
        requests = getRandomRequests();
        frames = new ArrayList<>(Collections.nCopies(framesNumber, 0));
        frameOrder = new ArrayList<>(Collections.nCopies(framesNumber, 0));	
		printRequestsAndFrames()
		
        int orderCounter = 1;
        for (int page : requests) {
            outputTextView.append(page + " | ");
            int minOrderIndex = 0;
            for (int i = 0; i < frames.size(); i++) {
                minOrderIndex =
                        frameOrder.get(i) < frameOrder.get(minOrderIndex) ? i : minOrderIndex;
                if (frames.get(i) == page) {
                    minOrderIndex = i;
                    break;
                }
            }
            if (frames.get(minOrderIndex) == page) {
                printFramesStatus(page);
                outputTextView.append(" #bingo!\n");
                continue;
            }
            frames.set(minOrderIndex, page);
            frameOrder.set(minOrderIndex, orderCounter++);

            printFramesStatus(page);
        }
}
\end{lstlisting}
\caption{Simulacija straničenja - FIFO strategija izbacivanja.}
\label{overflow}
\end{figure}
Za svaki zahtjev prolazi se kroz sve okvire. Ako se okvir već nalazi u memoriji ništa se ne mijenja i ispisuje se "bingo". U protivnom se pronalazi okvir koji je najstariji u memoriji (koji je najprije došao) i njega se zamjenjuje.\newpage

Rezultat simulacije na Android uređaju izgleda ovako:
\begin{figure}[ht!]
\centering
\includegraphics[width=70mm]{img/PagingActivity.png}
\caption{Simulacija straničenja.}
\label{overflow}
\end{figure}

\section{Upravljanje memorijom u Android aplikacijama}
\paragraph{}
Pri izradi Android aplikacija treba biti svijestan ograničenja memorije tokom svih faza razvoja, pa čak i prilikom izrade dizajna aplikacije neposredno prije samog početka razvoja. Takvim pristupom izbjegava se jako puno grešaka \textit{(engl. bug)} i curenja memorije \textit{(engl. memory leak)}, te se štedi vrijeme samog razvoja aplikacije. Postoje razne tehnike i dobre prakse vezane uz dizajn i pisanje koda koje povlače bolju kvalitetu same aplikacije i manje problema s memorijom, a u nastavku će se proći kroz one najbitnije.

\subsection{Pažljivo upravljanje servisima}
\paragraph{}
Pri korištenju nekog servisa za odrađivanje posla u pozadini, mora se jako paziti da  ne ostane pokrenut u trenucima kada ne obavlja aktivno niti jedan posao. Isto tako ne smije se dogoditi da servis procuri, što se događa kada ga se zaboravi zaustaviti nakon obavljenog posla. Takav propust smatra se jednom od najgorih grešaka kod upravljanja memorijom jer ne samo da će aplikacija lošije funkcionirati, nego će i korisnici primijetiti neočekivana ponašanja i pobrisati aplikaciju s uređaja.\\

Najbolji način za ograničavanje životnog spektra servisa je korištenje klase \textit{IntentService}, koja će se sama počistiti odmah nakon što odradi stvar zbog koje je pozvana.

\subsection{Otpuštanje memorije}
\paragraph{}
U bilo kojem trenutku života aplikacije, ugrađeni poziv \textit{(engl. callback)} \textit{onTrimMemory()} obavještava kada sveukupna memorija uređaja postaje premala. Na taj ugrađeni poziv trebalo bi odgovoriti otpuštanjem memorije resursa koji se drže u aplikaciji, a odluka o tome koje i koliko resursa otpustiti donosi se s obzirom na zaprimljeni nivo memorije od strane \textit{onTrimMemory()}. Nivoi memorije su sljedeći:

\paragraph{•}
\verb|TRIM_MEMORY_UI_HIDDEN|\\
Ovo je jedna od najvažnijih zastavica i indicira da je korisničko sučelje \textit{(engl. User Interface, UI)} trenutno skriveno od korisnika (npr. kada se korisnik navigira u drugu aplikaciju). To je signal da se trebaju osloboditi svi resursi koje trenutno koristi UI i tako znatno povećati kapacitet operacijskog sustava za spremanje procesa u priručnu memoriju, što je u krajnjoj liniji direktno poboljšanje kvalitete korisničkog korištenja aplikacije \textit{(engl. User Experience, UX)}.

\paragraph{•}
\verb|TRIM_MEMORY_RUNNING_MODERATE|\\
Aplikacija nije direktno ugrožena, sustav javlja da je slab s memorijom i počinje aktivno ubijati procese u LRU priručnoj memoriji.

\paragraph{•}
\verb|TRIM_MEMORY_RUNNING_LOW|\\
Aplikacija nije direktno ugrožena, sustav javlja da je puno slabiji s memorijom i ovdje bi se trebali već poćeti oslobađati nekorišteni resursi u aplikaciji.

\paragraph{•}
\verb|TRIM_MEMORY_RUNNING_CRITICAL|\\
Naša aplikacija još uvijek živi, ali sustav je već ubio većinu procesa u LRU priručnoj memoriji. Ovdje se trebaju otpustiti svi resursi koji nisu krucijalni za nastavak rada aplikacije.\\

\noindent
Ako je naš proces već u priručnoj memoriji i sustav primijeti da nedostaje slobodne memorije, možemo očekivati sljedeće zastavice:

\paragraph{•}
\verb|TRIM_MEMORY_BACKGROUND|\\
Proces je negdje na početku LRU liste. Iako nema prevelik rizik da ubrzo bude uništen, ovo je signal da se LRU priručna memorija već počinje čistiti i ovdje bi trebali osloboditi sve resurse koje je kasnije lako povratiti.

\paragraph{•}
\verb|TRIM_MEMORY_MODERATE|\\
Proces je negdje na sredini LRU liste i postoji dobra šansa da se uništi ako netko zatraži još dodatne memorije.

\paragraph{•}
\verb|TRIM_MEMORY_COMPLETE|\\
Proces je prvi koji će biti slijedeći uništen ako sustav u tom trenutku ne uspije osloboditi dovoljno memorije. Ovdje treba otpustiti apsolutno sve što nije krucijalno za nastavak rada aplikacije.\\

Ovaj ugrađeni poziv \textit{onTrimMemory()} je dodan tek u API verzije 14 tako da za starije verzije uređaja treba koristiti ugrađeni poziv \textit{onLowMemory()} koji se u principu ponaša isto kao i \verb|TRIM_MEMORY_COMPLETE| \textit{event}.

\subsection{Provjera dostupne memorije}
\paragraph{}
Kako je svaki android uređaj drukčiji i njegova količina radne memorije varira, isto tako mijenja se i limit veličine hrpe za svaku aplikaciju na uređaju. U slučaju da aplikacija pokuša zauzeti memoriju u trenutku kada je već dosegla svoj limit, dobiti će grešku \textit{OutOfMemoryError}, a pozivom na metodu \textit{getMemoryClass()} dobit će se procjena dostupne memorije za aplikaciju u megabajtima.\\

U posebnim slučajevima može se zatražiti veća količina hrpe postavljanjem atributa \textit{largeHeap} na \textit{true} unutar \textit{manifest} \verb|<application>| taga. Tada se procjena dostupne memorije za tu veću hrpu dobiva pozivom metode \textit{getLargeMemoryClass()}. Naravno to se nikako ne smije koristiti kao lako rješenje svaki puta kada se ostane bez memorije. Ovakav pristup namijenjen je malom broju aplikacija koje mogu opravdati potražnju za većom količinom memorije.

\subsection{Skaliranje bitmapa}
\paragraph{}
Prilikom učitavanja \textit{bitmap} datoteke, cilj je u memoriji držati samo rezoluciju koja nam treba za ekran trenutnog uređaja. Ako je originalna \textit{bitmap} datoteka prevelika, se mora skalirati na željenu veličinu. Ovime se štedi jako puno memorije jer količina memorije za držanje \textit{bitmap} datoteke raste kvadratno s porastom veličine grafike (jer rastu X i Y osi).

\subsection{Optimizirani spremnici podataka}
\paragraph{}
Radno okruženje Android nam nudi strukture za spremanje podataka koje su optimizirane za Android OS, kao na primjer \textit{SparseArray, SparseBooleanArray i LongSparseArray}. Ako uzmemo za primjer ostvarenje \textit{HashMap} strukture, ona može biti jako neugodna za memoriju jer prilikom svakog mapiranja stvara novi objekt. S druge strane \textit{SparseArray} klase su optimizirane tako da izbjegavaju potrebu automatske konverzije iz primitiva u klasu objekta \textit{(engl. autoboxing)}(npr. int u Integer) ključa, a ponekad i same vrijednosti.\\

Isto tako možemo iskoristiti i bazične \textit{Java} nizove kada to ima smisla.

\subsection{Dodatni troškovi memorije}
\paragraph{}
U izradi aplikacije jedna od najbitnijih stvari koje trebamo pripaziti je cijene i dodatni troškovi \textit{(engl. overhead)} jezika i radnog okruženja koje koristimo. Često se ljudi naviknu uzimati stvari zdravo za gotovo i rade greške koje na prvi pogled izgledaju nevino, dok ustvari troše veliku količinu memorije.

\paragraph{•}
Enumeracije \textit{(engl. Enumerations, Enum)} često zahtjevaju i do duplo više memorije od statičkih konstanta. Njih bi svakako trebali izbjegavati.

\paragraph{•}
Svaka klasa u \textit{Javi} koristi približno 500 bajta koda.

\paragraph{•}
Svaka instanca klase ima 12-16 bajta dodatnog troška u radnom spremniku.

\paragraph{•}
Stavljanje jednog unosa u \textit{HashMap}, zahtjeva zauzimanje memorije još jednog dodatnog objekta veličine 32 bajta.\\

Iako u prvu ruku ne izgleda kao prevelika štednja, kada se ovakve sitnice  skaliraju to jako brzo postaje veliki problem iz perspektive memorije.

\subsection{Apstrakcija koda}
\paragraph{}
Iako je apstrakcija koda dobra praksa u programiranju jer svojom fleksibilnošću olakšava održavanje aplikacije, ona dolazi s cijenom, a cijena je puno veća količina koda koji se treba izvesti, što povlači za sobom više radne memorije. Ako apstrakcije ne olakšavaju strukturu i fleksibilnost koda moraju se izbjegavati, jer će memorija biti jako zahvalna na tome.

\subsection{Mehanizam za serijalizaciju Protobuffs}
\paragraph{}
\textit{Protobuffs (Protocol buffers)} je mehanizam razvijen od strane \textit{Google-a} za serijalizaciju struktura podataka neovisni o jeziku i platformi. Nešto poput XML-a, međutim puno brži, manji i jednostavniji. Ako se koristi u kodu, na Android operacijskom sustavu uvijek bi se trebala uzeti nano verzija protobuffs mehanizma na klijentskoj strani koda. Time se značajno smanjuje korištenje memorije i veličina APK arhive, te se pritom ubrzava samo izvođenje programa.

\subsection{Ubrizgavanje zavisnosti}
\paragraph{}
Kada se koristi neko radno okruženje za ubrizgavanje zavisnosti (engl. dependency injection) kao \textit{Dagger} ili \textit{Guice}, iako olakšavaju samo kodiranje i testiranje aplikacije kontrolom dependency-a, moramo paziti na činjenicu da oni rade jako puno inicijalizacije procesa tijekom skeniranja našeg koda tražeći anotacije i time mapiraju u radnu memoriju značajnu količinu koda iako nam taj kod u memoriji i ne treba. Te stranice su mapirane u čistu memoriju kako bi ih Android mogao počistiti, no to će se dogoditi tek nakon što stranice odstoje u memoriji neko vrijeme nekorištene.

\subsection{Eksterne biblioteke}
\paragraph{}
Na eksterne biblioteke treba uvijek posebno paziti, pogotovo kada ih se koristi više u jednom projektu. Prvo se dolazi do problema kada biblioteka nije optimizirana za korištenje na mobilnim uređajima, u kojem će se slučaju morati preuzeti pisanje optimizacije i održavanje tog koda. S druge strane i onda kada su biblioteke navodno optimizirane za mobilne uređaje, tu imamo potencijalni problem kada više njih rade istu stvar na različite načine i javljaju se veliki dodatni troškovi memorije. Na primjer, ako koristimo dvije biblioteke s različitim ostvarenjima za \textit{logging, caching, analytics} i slično.

\subsection{Proguard}
\paragraph{}
Proguard je jako koristan alat koji smanjuje, optimizira i pomućuje (engl. obfuscates) kod. To radi tako da makne kod koji se ne koristi, te zamijeni imena varijabli, klasa i metoda sa semantički besmislenim imenima. 

\subsection{Poravnavanje finalne APK arhive}
\paragraph{}
Nakon što se potpiše produkcijska verzija aplikacije mora se i poravnati \textit{zipalign} alatom. U protivnom, aplikacija će trošiti znatno više radne memorije, jer se resursi neće moći automatski mapirati iz APK-a.

\begin{center}
\verb|zipalign [-f] <alignment> infile.apk outfile.apk|
\end{center}

Za \textit{alignment} parametar koristi se 4 bajta na android okruženju, a zastavica –f forsira prepisivanje rezultata preko postojeće \textit{outfile.apk} datoteke.

\subsection{Analiza korištenja radne memorije}
\paragraph{}
Kako bi se dobio bolji uvid u funkcionalnost naše aplikacije, svaki stabilan \textit{build} bilo bi dobro analizirati.
Prvi i najjednostavniji način je čitanje informacijskih poruka \textit{(engl. log)} sakupljača smeća. Dok virtualni stroj Dalvik svaki put ispisuje poruke sakupljača smeća, ART ispisuje samo one koje su eksplicitno zahtjevane.\\

Druga stvar koja nam pomaže je \textit{Android Debug Monitor} u Android Studiu koji prikazuje raznovrsne informacije o stanju memorije i uređaja općenito.\\

\begin{figure}[ht!]
\centering
\includegraphics[width=140mm]{img/android-debug-monitor.png}
\caption{Android debug monitor.}
\label{overflow}
\end{figure}

Za detaljniju analizu može se pogledati kako je memorija naše aplikacije podijeljena po raznim tipovima zauzeća radnog spremnika pomoću \textit{adb} naredbe:

\begin{center}
\verb=adb shell dumpsys meminfo <package_name | pid> [-d]=
\end{center}
koja daje rezultat sličan ovome:

\begin{figure}[ht!]
\centering
\begingroup
    \fontsize{9pt}{12pt}\selectfont
		\begin{verbatim}
		** MEMINFO in pid 18227 [com.google.android.apps.maps] **
		                   Pss  Private  Private  Swapped     Heap     Heap     Heap
		                 Total    Dirty    Clean    Dirty     Size    Alloc     Free
		                ------   ------   ------   ------   ------   ------   ------
		  Native Heap    10468    10408        0        0    20480    14462     6017
		  Dalvik Heap    34340    33816        0        0    62436    53883     8553
		  ...
		  ...
		        TOTAL   216524   208232     4384        0    82916    68345    14570
\end{verbatim}
\endgroup
%\includegraphics[width=120mm]{img/example.png}
\caption{Analiza memorije procesa.}
\label{overflow}
\end{figure}

\noindent
i ovdje nam je bitno raspoznati dvije stvari:


\paragraph{•}
\textbf{Privatni čisti i prljavi radni spremnik} \textit{(engl. Private Clean and Dirty RAM)}\\
Ovo je količina memorije koju koristi naš proces i to je onaj dio memorije koji sustav može dobiti nazad nakon uništavanja istog. Ovdje je najbitnije gledati prljavi dio radnog spremnika, koji je ujedno i najskuplji, jer se tim djelom koristi samo taj process i ne može se straničiti na disk.

\paragraph{•}
\textbf{Proporcionalna veličina skupa} \textit{(engl. Proportional Set Size, PSS)}\\
Ovo je količina memorije koju koristi aplikacija uzimajući u obzir dijeljenje stranica kroz više procesa. Svaka stranica koja je jedinstvena za naš process direktno pridonosi ovoj vrijednosti, dok ostale stranice koje se dijele s drugim procesima doprinose proporcionalnu vrijednost dijela kojeg zauzimaju.

\subsection{Korištenje više procesa}
\paragraph{}
Iako velika većina aplikacija ne bi smjela koristiti više procesa u isto vrijeme, jer bi se mogli opeći i umjesto smanjenja, povećati iznos otiska \textit{(engl. footprint)} aplikacije u radnoj memoriji. No ako se ipak ide ovim putem mora se obratiti pažnja kakve će to utjecaje imati na našu memoriju.\\

Za ilustraciju posljedica zamislit će se jedan prazni process koji ne radi apsolutno ništa, i takav process ima dodatnih 1.4MB otiska u radnoj memoriji.

\begin{figure}[ht!]
\centering
\begingroup
    \fontsize{8pt}{12pt}\selectfont
		\begin{verbatim}
adb shell dumpsys meminfo com.example.android.apis:empty

** MEMINFO in pid 10172 [com.example.android.apis:empty] **
                Pss     Pss  Shared Private  Shared Private    Heap    Heap    Heap
              Total   Clean   Dirty   Dirty   Clean   Clean    Size   Alloc    Free
             ------  ------  ------  ------  ------  ------  ------  ------  ------
  Native Heap     0       0       0       0       0       0    1864    1800      63
  Dalvik Heap   764       0    5228     316       0       0    5584    5499      85
 Dalvik Other   619       0    3784     448       0       0
        Stack    28       0       8      28       0       0
    Other dev     4       0      12       0       0       4
     .so mmap   287       0    2840     212     972       0
    .apk mmap    54       0       0       0     136       0
    .dex mmap   250     148       0       0    3704     148
   Other mmap     8       0       8       8      20       0
      Unknown   403       0     600     380       0       0
        TOTAL  2417     148   12480    1392    4832     152    7448    7299     148
		\end{verbatim}
\endgroup
%\includegraphics[width=120mm]{img/example.png}
\caption{Analiza memorije praznog procesa.}
\label{overflow}
\end{figure}

Može se primijetiti da veličina nije baš zanemariva, i isto tako brzo i raste porastom kompleksnosti posla tog procesa. Na primjer, process koji prikazuje jedan \textit{Activity} sa tekstom će zauzeti 4MB, što je tri puta više, i to samo za prikazivanje običnog teksta na UI.\\

Ovime se dolazi do konkretnog zaključka, ako se već aplikacija dijeli u procese,\linebreak isključivo jedan process mora biti zadužen za UI, a ostali moraju izbjegavati bilo kakvo korištenje UI elemenata, jer u suprotnom ćemo napuniti memoriju u kratkom roku.\\

Dodatno, kako se aplikacija obavlja u više procesa mora se puno više fokusa uložiti u optimizaciju korištenja memorije u kodu jer se u ovom slučaju svaki propust replicira na druge procese i stvara sve veći problem.

\pagebreak
\chapter{Procesi i dretve}
\section{Uvod}
\paragraph{}
Pri pokretanju nove aplikacije, ako aplikacija nema niti jednu komponentu već pokrenutu, Android će pokrenuti novi Linux proces za tu aplikaciju s jednom dretvom. Po pravilu, sve komponente iste aplikacije pokreću se u istom procesu i dretvi. To je glavna dretva \textit{(engl. main thread)}. Ako prilikom pokretanja neke komponente već postoji proces koji je zadužen za tu aplikaciju (jer postoji neka druga komponenta koja je već pokrenuta) onda se nova komponenta pokreće unutar toga procesa i koristi istu dretvu za izvršavanje. Naravno, svaku komponentu može se specifično izdvojiti u drugi proces ili napraviti više dretvi za bilo koji proces.

\section{Procesi}
\paragraph{}
Iako su sve komponente po pravilu pokrenute u istom procesu (i to se u većini slučajeva ne bi trebalo mijenjati), postoji mogućnost potpune kontrole nad njima i može se lako promijeniti proces kojem će komponenta pripadati. To se radi u datoteci \textit{AndroidManifest.xml}. Svaki unos elementa android komponente u \textit{manifestu} - \verb|<activity>,| \verb|<service>, <receiver>, <provider>| - sadrži atribut \textit{android:process} gdje se može specificirati ime procesa u kojem će komponenta živjeti.\newpage

\begin{figure}[ht!]
\centering
\begingroup
		\begin{lstlisting}
        <activity android:icon="drawable resource"
            android:label="string resource"
            android:name="string"
          	    . . .
            android:process="string"
          	    . . .
        </activity>
		\end{lstlisting}
\endgroup
%\includegraphics[width=120mm]{img/example.png}
\caption{Element \textit{Activity} unutar AndroidManifest.xml.}
\label{overflow}
\end{figure}

Isto tako, \verb|| element podržava \textit{android:process} atribut koji onda postavlja unaprijed zadanu \textit{(engl. default)} vrijednost za sve komponente aplikacije. Unaprijed zadano ime procesa odgovara imenu paketa aplikacije koje je određeno u \textit{manifestu}.\\

Ako ime procesa počinje s dvotočkom \textit{(':')}, novi privatan proces za aplikaciju stvara se tek onda kada je potreban i komponenta se pokrene unutar njega. U slučaju da ime procesa započinje malim slovom, \textit{activity} će se pokrenuti u globalnom procesu tog imena ako ima ovlasti za to. Ovime se omogućuje komponentama iz različitih aplikacija da dijele procese, te smanjujemo potrošnju resursa.\\

Android se u bilo kojem trenutku može odlučiti ubiti proces, kad je memorija pri kraju, a drugi procesi koji su trenutačno važniji za posluživanje korisnika ju zahtijevaju. U tom slučaju komponenta aplikacije bude uništena skupa s procesom, i oni se ponovno pokreću kada se to od njih bude tražilo.


\subsection{Život procesa}
\paragraph{}
Android ima u cilju što duže zadržati proces aplikacije živim, dok ga eventualno ne uništi kako bi oslobodio memoriju za nove ili važnije procese. Za takvu vrstu odluke procesi se stavljaju u \textit{hijerarhiju po važnosti}. Ta hijerarhija bazirana je na pokrenutim komponentama u procesu i njihovom trenutnom stanju, te se onda postepeno izbacuju procesi od najmanje važnosti.\\

Postoji pet stupnjeva \textit{hijerarhije po važnosti}. U sljedećoj listi prikazani su različiti tipovi procesa po važnosti (prvi je najvažniji, odnosno zadnji se ubija):

\begin{enumerate}
\item
\textbf{Proces u prvom planu} \textit{(engl. Foreground process)}\\
Proces koji je potreban za ono što korisnik trenutno radi i vidi. Smatra se da je proces u prvom planu ako je ispunjen jedan od slučajeva:
	\begin{itemize}
	\item sadrži \textit{activity} s kojim korisnik komunicira – pozvana metoda \textit{onResume()} nad \textit{activity-em}
	\item sadrži servis koji je povezan s \textit{activity-em} s kojim korisnik komunicira
	\item sadrži servis koji je pokrenut u prvom planu – pozvana metoda \textit{startForeground()} servisa
	\item sadrži servis koji pokreće jedan od svojih glavnih ugrađenih poziva – \textit{onCreate(), onStart() ili onDestroy()}
	\item sadrži \textit{BroadcastReceiver} koji trenutno izvršava metodu \textit{onReceive()}
	\end{itemize}
U stvarnosti će  u bilo kojem danom trenutku biti svega par takvih procesa pokrenutih i njihovo se ubijanje smatra zadnjom opcijom, a to je kada nema dovoljno memorije da se svi izvršavaju odjednom. U tom trenutku uređaj je u stanju straničenja memorije, pa je ubijanje ovih procesa potrebno kako bi održali UI responzivnim.	
	
\item
\textbf{Vidljivi procesi}\\
Proces je vidljiv ako nema nijednu komponentu u prvom planu, ali utječe na ono što korisnik vidi na ekranu. Smatra se da je proces vidljiv ako je ispunjen jedan od slučajeva:
	\begin{itemize}
	\item sadrži \textit{activity} koji nije u prvom planu, ali je vidljiv korisniku – pozvana metoda \textit{onPause()} (npr. kad se otvori dijalog, roditeljski \textit{activity} je još uvijek vidljiv ispod njega)
	\item sadrži servis koji je vezan za vidljivi ili \textit{activity} u prvom planu
	\end{itemize}
Ovakav se proces smatra iznimno važnim i neće se dirati ako to nije potrebno da bi procesi u prvom planu preživjeli.

\item
\textbf{Proces Servisa}\\
Proces koji ima servis pokrenut s metodom \textit{startService()} i koji nije pripadnik prve dvije kategorije.\\
Iako servisi inače nisu direktno povezani s onime što korisnik vidi, oni rade stvari koje su bitne za krajnjeg korisnika (npr. puštanje muzike u pozadini) tako da ih Android drži živima dok ima dovoljno memorije da prežive i procesi u prvom planu i svi vidljivi procesi.

\item
\textbf{Proces u pozadini}\\
Proces koji sadrži \textit{activity} koji trenutno nije vidljiv korisniku – pozvana je \linebreak metoda \textit{onStop()}.\\
Takvi procesi nemaju nikakav utjecaj na UX, tako da ih Android u bilo kojem trenutku može ubiti s ciljem oslobađanja memorije. U stvarnosti će u bilo kojem danom trenutku biti puno procesa koji se izvode u pozadini, i oni se spremaju u LRU priručnu memoriju kako bi se osiguralo pravedno uništavanje aplikacija po prioritetu najmanjeg korištenja istih.

\item
\textbf{Prazan proces}\\
Proces koji ne sadrži niti jednu aktivnu komponentu aplikacije.\\
Jedini razlog da bi uopće postojao ovakav proces je zbog korištenja priručne memorije i bržeg pokretanja komponenti koje će se unutar ovog procesa pokretati u budućnosti.

\end{enumerate}

Tijekom rangiranja procesa Android uzima najveći mogući stupanj hijerarhije koji je zadovoljen. Ako proces sadrži i servis i vidljivi \textit{activity}, biti će rangiran kao vidljivi proces, a ne kao proces servisa.\\

Isto tako, proces može biti promaknut ako postoji neki drugi proces koji ovisi o njemu – jer proces ne smije biti manje rangiran od procesa kojeg poslužuje. Dobar primjer za to daju klase \textit{ContentProvider} ili servisi koji su vezani za neku komponentu u drugom procesu.\\

Može se primijetiti da je proces servisa više rangiran od procesa u pozadini, tako da ako u aplikaciji radimo neki posao koji ima veće trajanje nego obično (npr. upload datoteke) najbolje je da sav posao prebacimo u novi servis nego da ga odrađujemo na radnoj dretvi \textit{(engl. worker thread)}. Time dobivamo sigurnost da će proces biti rangiran kao proces servisa, bez obzira na to što se dogodi sa \textit{activity-em}. Iz istog razloga je i dobra praksa u klasi \textit{BroadcastReceiver} uposliti servise umjesto da opterećujemo dretvu.

\subsection{Komunikacija između procesa}
\paragraph{}
Za komunikaciju između različitih procesa Android koristi RPC pozive \textit{(engl.\linebreak Remote Procedure Call, RPC)}, gdje poziva metodu iz \textit{activityj-a} ili neke druge komponente aplikacije i ista se izvršava u drugom procesu, te nakon izvršavanja vraća rezultat pozivatelju. Na ovaj se način poziv metode rastavlja na nivo operacijskog sustava i prenosi se iz lokalnog procesa i adresnog prostora na drugi proces i njegov adresni prostor te tamo izvršava naredbe pozvane metode i vraća rezultat na isti način u drugom smjeru. Android rješava sav kod za transakcije komunikacije između procesa \textit{(engl. Interprocess Communication, IPC)} tako da je sve što se treba napraviti definicija i ostvarenje RPC sučelja (engl. interface).\\

Kako bi obavili IPC komunikaciju, aplikacija se mora vezati za servis metodom \textit{bindService()} koja vraća klijent-server sučelje preko kojeg komponente aplikacije komuniciraju sa servisom. Takav povezani servis \textit{(engl. Bound Service)} živi sve dok ima neku komponentu bilo koje druge aplikacije povezanu na sebe. Pošto je moguće spojiti više komponenata odjednom na jedan takav servis, u trenutku kada se sve komponente odspoje, servis će se uništiti. Na ovaj način otvaramo dostupnost djela funkcionalnosti naše aplikacije ostalim aplikacijama preko IPC komunikacije.\\

Kako bi kreirali vezani servis, mora se ostvariti metoda \textit{onBind()} ugrađenog poziva gdje se vraća \textit{IBinder} koji služi kao sučelje za komunikaciju sa samim servisom. Nakon toga ostale se komponente mogu jednostavno spojiti na servis pozivom metode \textit{bindService()} nakon čega dobivaju sučelje preko kojega mogu početi pozive metoda na servisu. Kako se operacijski sustav brine za uništavanje vezanih servisa kada ne postoji niti jedna komponenta vezana za njega, znači da nije potrebno ručno zaustavljanje ovakvog servisa.
 
\section{Dretve}
\paragraph{}
Pri pokretanju aplikacije, sustav kreira glavnu dretvu odgovornu za izvršavanje\linebreak programa pod nazivom "glavna dretva" \textit{(engl. main thread)}. Ova dretva je praktički najvažnija u cijeloj aplikaciji jer delegira slanje svih događaja \textit{(engl. event)} na odgovarajuće elemente grafičkog sučelja \textit{(engl. User Interface, UI)}, uključujući i događaje vezane za crtanje. Također u toj se dretvi odvija interakcija s ostalim komponentama iz \textit{Android UI toolkit} paketa, te kao takva, glavna se dretva ponekad naziva i "UI" dretva.\\

Sve komponente aplikacije koje se obavljaju u istom procesu pokreću se na UI dretvi i sustav nikada ne kreira nove dretve za svaku instancu komponente. Isto tako i sistemski pozivi aplikacije, kao i metode za odgovor na sistemski ugrađeni poziv uvijek se pokreću na UI dretvi procesa. Na primjer, kada korisnik pritisne gumb na ekranu, aplikacija šalje događaj dodira elementu, nakon čega se isti postavi u kliknuto stanje, te invalidira događaj u redu događaja \textit{(engl. event queue)}. Nakon toga UI dretva miče događaj iz reda i obavještava element da se promijenio i da se mora ponovno nacrtati.\\

Ovakav jednodretveni model ima i jednu jako veliku manu. U slučaju da aplikacija obrađuje jako veliku količinu posla kao rezultat neke akcije od strane korisnika, to može rezultirati jako lošim performansama aplikacije ako se to napravi na krivi način. Kada bi se sav taj posao odrađivao na UI dretvi, ona bi automatski postala blokirana dok se posao ne obavi do kraja, što bi značilo nemogućnost slanja nikakvih daljnjih događaja, uključujući i one za crtanje. Gledajući iz perspektive korisnika, aplikacija će se smrznut i prestati reagirati, a ukoliko bude smrznuta više od 5 sekundi, Android će pokazati korisniku poznati \textit{"application not responding" (ANR)} dijalog. Korisnik se tada može odlučiti na ubijanje aplikacije i pobrisati ju s uređaja ako je nezadovoljan istom. Ovakva situacija bi se svakako trebala izbjeći pod svaku cijenu.\\

Još jedan jako bitan detalj je da \textit{Android UI toolkit} nije dretveno osiguran \textit{(engl. thread-safe)}, što bi značilo da se njegovi elementi ne mogu mijenjati iz više dretvi istovremeno. Iz tog se razloga ne smije manipulirati UI elementima iz druge dretve, već se sva manipulacija na UI elementima radi na UI dretvi.\\

Iz ovog osnovnog pogleda na dretve u Androidu okruženju izašla su dva zlatna pravila za ovakav jednodretveni model kojih bi se svatko trebao držati:

\begin{enumerate}
\item Nikada ne blokirati UI dretvu.
\item Nikada ne pristupati \textit{Android UI toolkit} elementima od izvana UI dretve.
\end{enumerate}

\subsection{Radna dretva}
\paragraph{}
Poštujući prvo pravilo jako je bitno ne blokirati UI dretvu zbog responzivnosti cijele aplikacije. Ukoliko dođe situacija da neki posao nije moguće odmah izvršiti, već je potrebno neko vrijeme za to (npr. dohvaćanje slike sa interneta), takvu stvar moramo staviti u posebnu dretvu - "pozadinska" \textit{(engl. background thread)}  ili "radna" dretva \textit{(engl. worker thread)}.\newpage
Ovo je primjer kako u slušatelju za događaj klika \textit{(engl. click listener)} dohvaćamo sliku s interneta na radnoj dretvi i prikazujemo ju u \textit{ImageView}:

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}
public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            Bitmap bitmap = loadImageFromNetwork("http://example.com/image.png");
            mImageView.setImageBitmap(bitmap);
        }
    }).start();
}
\end{lstlisting}
\caption{Dohvaćanje slike u radnoj dretvi.}
\label{overflow}
\end{figure}

Na prvi pogled sve se čini ok, napravila se nova dretva koja onda dohvaća sliku i stavi je u \textit{imageView} kako je i planirano. Međutim, kada se sjetimo drugog pravila dretvi koje govori da se nikako ne smije pristupati \textit{Android UI toolkit} elementima izvan UI dretve, uviđamo da se upravo to događa u ovoj novoj radnoj dretvi. Ovaj kod može rezultirati neočekivanim ponašanjem aplikacije i samim time se produljuje i otežava razvoj aplikacije i lovljenje bugova.\\

Ovo je poznati problem i Android nudi nekoliko rješenja:

\begin{itemize}
\item[•] \textit{Activity.runOnUiThread(Runnable action)}
\item[•] \textit{View.post(Runnable action)}
\item[•] \textit{View.postDelay(Runnable action, long delay)}
\end{itemize}
\paragraph{}
Metode primaju \textit{Runnable} akciju koja će se izvršiti na UI dretvi i isto tako se može dodati parametar \textit{delay} tipa \textit{long} koji predstavlja milisekunde čekanja prije nego se akcija izvrši na UI dretvi.\newpage 
Navedeni primjer može odmah popraviti:

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}
public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            final Bitmap bitmap =
                    loadImageFromNetwork("http://example.com/image.png");
            mImageView.post(new Runnable() {
                public void run() {
                    mImageView.setImageBitmap(bitmap);
                }
            });
        }
    }).start();
}
\end{lstlisting}
\caption{Osvježavanje slike na UI dretvi.}
\label{overflow}
\end{figure}

Može se primijetiti da je ovaj kod u potpunosti dretveno osiguran, dohvaćanje slike obavlja se u zasebnoj dretvi, dok se manipulacija \textit{ImageView-a} odvija na UI dretvi.\\

Isto tako može se vidjeti da kako se povećava kompleksnost operacija, ovakvo rješenje postaje sve kompliciranije i teže za održavanje. Ovdje će pomoći korištenje rukovatelja \textit{(engl. Handler)} u radnoj dretvi koji procesuira poruke dobivene sa UI dretve, a još bolje rješenje bi bilo proširivanje \textit{(engl. extend)} \textit{AsyncTask} klase jer pojednostavljuje pisanje koda koji bi se odvijao na radnoj dretvi i komunicirao sa UI elementima na UI dretvi.

\subsection{klasa \textit{AsyncTask}}
\paragraph{}
Klasa \textit{AsyncTask} omogućuje i olakšava pravilno korištenje UI dretve. Ona služi za izvršavanje blokirajućih operacija u pozadini i prikazivanje rezultata na UI dretvi bez potrebe da sami manipuliramo dretvama i rukovateljima. Stoga je \textit{AsyncTask} zapravo pomoćna klasa vezana za \textit{Thread} i \textit{Handler} i nije zamišljen kao radno okruženje za upravljanje dretvama. Idealno se koristi za operacije do svega par sekundi, a za sve ostale stvari koje bi se trebale duže odrađivati u pozadini koriste se API koji se nalaze u \verb|java.util.concurrent| paketu (npr. \textit{Executor, ThreadPoolExecutor, FutureTask}).\\

Svaki \textit{AsyncTask} definiran je s tri generička tipa \textit{Params, Progress i Result}, i dijeli se u četiri koraka izvršavanja, a to su \textit{onPreExecute(), doInBackground(), onProgressUpdate() i onPostExecute().}\\

Pri korištenju klase \textit{AsyncTask}, prvo se radi odgovarajuća subklasa gdje se onda ostvaruje metoda doInBackground() koja se zatim pokreće u bazenu dretvi \textit{(engl. thread pool)} u pozadini. Osvježavanje UI elemenata radi se u metodi \textit{onPostExecute()} gdje dobivamo rezultat iz \textit{doInBackground()} dijela, te pokreće promjene na UI dretvi.\linebreak Nakon ostvarenja, \textit{AsyncTask} se pokreće metodom \textit{execute()}.\\

Nadalje, mora se obratiti pažnja na sljedeće stvari:

\begin{itemize}
\item[•] \textit{Activity.runOnUiThread(Runnable action)}
\item[•] \textit{View.post(Runnable action)}
 \textit{View.postDelay(Runnable action, long delay)}

\item[•] Tipove parametara možemo sami specificirati pomoću generičkih tipova \textit{(engl. generics)}
\item[•] \textit{doInBackground()} se automatski pokreće na radnoj dretvi
\item[•] \textit{onPreExecute(), onPostExecute(), i onProgressUpdate()} se pokreću na UI dretvi
\item[•] vrijednost dobivena u \textit{doInBackground()} predaje se \textit{onPostExecute()} metodi
\item[•] \textit{publishProgress()} se može pozvati bilo kada u \textit{doInBackground()} kako bi se okinuo \textit{onProgressUpdate()} na UI dretvi
\item[•] prekid izvađanje \textit{AsyncTask} klase može se napraviti bilo kada iz bilo koje dretve\newpage
\end{itemize}
\paragraph{}
Za ilustraciju, primijenit ćemo \textit{AsyncTask} na prethodni primjer:

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}
public void onClick(View v) {
    new DownloadImageTask().execute("http://example.com/image.png");
}

private class DownloadImageTask extends AsyncTask<String, Void, Bitmap> {
    /** Sustav poziva ovu metodu i izvrsava u radnoj dretvi te
      * prosljedjuje parametre dobivene u AsyncTask.execute() */
    protected Bitmap doInBackground(String... urls) {
        return loadImageFromNetwork(urls[0]);
    }

    /** Sustav poziva ovu metodu i izvrsava ju na UI dretvi i
      * prosljedjuje rezultat dobiven iz doInBackground() */
    protected void onPostExecute(Bitmap result) {
        mImageView.setImageBitmap(result);
    }
}
\end{lstlisting}
\caption{Dohvaćanje slike pomoću \textit{AsyncTask} klase.}
\label{overflow}
\end{figure}

Ovdje se vidi puno jednostavniji stil kodiranja, a i UI dretva je u potpunosti sigurna jer se odvaja posao koji se odrađuje na radnoj dretvi od djela koji se treba raditi na UI dretvi.\newpage

\chapter{Sinkronizacijski mehanizmi}
\section{Sinkronizacija procesa semaforima}
\paragraph{}
Sinkronizacija procesa se uglavnom obavlja monitorima, a za jednostavnije probleme sinkronizacije koristimo semafore. Ostali mehanizmi (čija primarna namjena nije sinkronizacija, poput redova poruka, cjevovoda, i sl.) rijetko se koriste za sinkronizaciju procesa.\\

Semafor je mehanizam koji sprečava da dva ili više procesa pristupaju zajedničkom sredstvu istovremeno. Binarni semafor ima dva stanja: propusno i nepropusno. Opći semafor ima beskonačan broj stanja (ili barem vrlo velik). To je brojač koji se smanjuje za jedan kada se zahtijeva semafor, a povećava se za jedan kada se oslobađa. Ako je na nuli, a proces zahtijeva semafor, tada taj proces mora čekati dok drugi proces ne poveća vrijednost semafora. Semafor u UNIX-u (System V) ne može imati negativnu vrijednost iako su teoretski ostvarivi i semafori kod kojih bi bile dozvoljene i negativne vrijednosti. Upotreba semafora se obično razmatra kroz dvije jednostavne operacije: "dohvati" \textit{(engl. acquire)} i "otpusti" \textit{(engl. release)} ili "čekaj" \textit{(engl. wait)} i "postavi" \textit{(engl. signal)}.\\

Android radno okruženje nudi klasu \textit{Semaphore}, tipa općeg semafora, koja zapravo konceptualno upravlja setom dozvola. Svaki \textit{acquire()} poziv blokira pristup ako je potrebno sve dok ne dobije dozvolu od semafora, koju potom uzima. S druge strane imamo \textit{release()} poziv koji vraća dozvolu semaforu i time potencijalno oslobađa blokiranog pozivatelja dozvole.\\

Ako inicijaliziramo semafor na veličinu 1, on postaje lokot međusobnog isključivanja \textit{(engl. mutual exclusion lock)}, odnosno binarni semafor, jer ima samo dva stanja 0 ili 1 dozvola je dostupna u svakom trenutku. Kada se koristi na ovaj način, binarni semafor dobiva specifično svojstvo (za razliku od ostalih ostvarenja lokota \textit{(engl. Lock)}) da se može otpustiti iz bilo koje dretve koja nije vlasnik, jer semafori nemaju vlasnika. Ovo zna biti jako korisno kod oporavljanja iz stanja potpunog zastoja \textit{(engl. deadlock)}.\\

Također, konstruktor osim broja dozvola prima i parametar \textit{fairness}. Kada je postavljen na \textit{false} semafor ne garantira nikakvim poretkom kojim će dretve dobivati dozvole. To bi značilo da jedna dretva pozivom na \textit{acquire()} može dobiti dozvolu prije dretve koja već čeka na istu. Kada je postavljen na \textit{true} semafor garantira točan poredak dobivanja dozvola onim redom kako su ih dretve zatražile (FIFO).\\

U principu bi se semafori trebali inicijalizirati kao pošteni, kako bi izbjegli predugo čekanje jedne dretve na resurs.

\section{Sinkronizacija dretvi}
\paragraph{}
Kada dretve koriste zajedničke varijable, njihov istovremeni pristup tim podacima mora se strogo kontrolirati zbog kolizije. Takav kritični odsječak programa obavezno se zaštićuje međusobnim isključivanjem.\\

Android nam nudi tri rješenja za ovaj problem: \textit{Lock, ReadWriteLock i Condition}.

\subsection{Lokot}
Lokot \textit{(engl. Lock)} nam daje veću kontrolu nad zaključavanjem operacija od običnih \textit{synchronized} metoda. To je alat koji kontrolira pristup nekom resursu od više dretvi. U jednom trenutku samo jedna dretva može koristiti navedeni resurs, i svako korištenje isključivo traži dobiven pristup za tu akciju od strane lokota.

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}
 			Lock l = ...;
 			l.lock();
 			try {
   				// pristupanje resursu kojeg stiti lokot
		  	finally {
		   		l.unlock();
 			}}
\end{lstlisting}
\caption{Pristupanje resursu pod zaštitom lokota.}
\label{overflow}
\end{figure}

\subsection{Lokot optimiziran za čitanje}
Kako bi se optimiziralo vrijeme čekanja na pristup resursu, klasa \textit{ReadWriteLock} rukuje sa parom lokota, jedan u svrhu čitanja resursa, a drugi za pisanje. Specifična je po tome što lokot za čitanje može biti dostupan većem broju dretvi koje čitaju jedan resurs, sve dok ne postoji niti jedna koja želi pisati u isti.
Time omogućava veći nivo paralelnosti izvođenja i u teoriji dovodi do velikog poboljšanja u performansama programa, osim u slučaju kada su česti zahtjevi za pisanjem.

\subsection{Uvjetne varijable}
Klasa Condition daje svojstva uvjetne varijable. Ona pruža metode monitora (\textit{wait(), notify(), notifyAll()}) u jedinstvenim objektima i time imamo mogućnost sadržavanja više čekaj-odobri (engl. wait-set) uvijeta koje onda možemo spojiti sa našim ostvarenjem lokota. 
Ove varijable se koriste kako bi zaustavili izvođenje jedne dretve (\textit{čekaj}), sve dok druga dretva ne odobri nastavak rada na temelju nekog zadovoljenog uvjeta(\textit{odobri}).
Svaka instance \textit{Condition} klase povezuje se na instance lokota pomoću metode \textit{newCondition()}.

\section{Dekkerov algoritam - praktični dio}
\paragraph{}
Dekkerov je algoritam prvo pravo rješenje problema međusobnog isključivanja. On dopušta dvjema dretvama korištenje istog resursa bez konflikta, korištenjem isključivo dijeljene memorije u svrhu komunikacije, te garantira međusobno isključivanje, zaštitu od stanja zapetljanih lokota \textit{(engl. deadlock)} i zaštitu od izgladnjivanja \textit{(engl. starvation)} \\

U svrhu demonstracije algoritma na Android okruženju pokazat će se primjer dvije dretve koje rade neki posao od pet koraka i ispisuju svaki korak na ekran u \textit{TextView}. Biti će nam potrebne zastavice \textit{wantsToEnter} koje označavaju namjeru dretve za ulazak u kritični odsječak, te varijabla \textit{turn} koja označava koja od dretvi je na redu.\newpage

Za početak, ostvariti ćemo metode ulaska i izlaska iz kritičnog odsječka.

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}[
    basicstyle=\footnotesize , %or \small or \footnotesize etc.
]
    private void enterCriticalSection() {
        wantsToEnter[id] = true;
        while (wantsToEnter[(id+1)%2]) {
            if (turn != id) {
                wantsToEnter[id] = false;
                while (turn != id) {
                    // busy wait
                    try {
                        Thread.sleep(230);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                wantsToEnter[id] = true;
            }
        }
    }
    private void exitCriticalSection() {
        turn = (id + 1) % 2;
        wantsToEnter[id] = false;
    }
\end{lstlisting}
\caption{Dekkerov algoritam - Ulazak i izlazak iz kritičnog odsječka.}
\label{overflow}
\end{figure}

Kada dretva želi ući u kritični odsječak a nije njezin red, ona radi prazni posao \textit{(engl. busy wait)} i čeka svoj dolazak na red. Pri izlasku dretve iz kritičnog odsječka, red se prebacuje na drugu dretvu i ona automatski uzima kritični odsječak za svoj posao.\newpage

Nakon toga se radi ostvarenje \textit{Runnable} klase koja predstavlja posao za radnu dretvu.

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}[
    basicstyle=\footnotesize , %or \small or \footnotesize etc.
]
public class DekkerRunnable implements Runnable {
    public static volatile int turn = 0;
    public static volatile boolean[] wantsToEnter = {false, false};
    ...
    @Override public void run() {
        for (k = 1; k <= 5; k++) {
            enterCriticalSection();
             print(5);
            exitCriticalSection();
             Thread.sleep(500);
        }
    }
    private void print(int times) {
        for (m = 1; m <= times; m++) {
            // update UI thread with data
            new Handler(Looper.getMainLooper()).post(new Runnable() {
                @Override
                public void run() {
                    outputTextView.append("Thread: " + id + ", C.S. NO: " + k + " (" + m + "/5)\n");
                }
            });
            Thread.sleep(1000);
        }
    }

\end{lstlisting}
\caption{Ostvarenje \textit{DekkerRunnable}.}
\label{overflow}
\end{figure}

Ovdje je dobro uočiti da se \textit{TextView} osvježava sa novim podacima u glavnoj UI dretvi.\newpage

Na kraju se rade dvije radne dretve sa instancama \textit{DekkerRunnable} ostvarenja i koje onda rade svoj posao i međusobno se isključuju. To se pokreće na klik gumba.

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}[
    basicstyle=\footnotesize , %or \small or \footnotesize etc.
]
            public void onClick(View view) {
                Thread thread1 = new Thread(new DekkerRunnable(0, outputTextView));
                thread1.start();
                Thread thread2 = new Thread(new DekkerRunnable(1, outputTextView));
                thread2.start();
				}
\end{lstlisting}
\caption{Pokretanje radnih dretvi klikom na gumb.}
\label{overflow}
\end{figure}

Nakon klika za pokretanje radnih dretvi one će ispisivati svoj posao na ekran kao što  se vidi na sljedećoj slici.

\begin{figure}[ht!]
\centering
\includegraphics[width=70mm]{img/DekkerActivity.png}
\caption{Ispis programa koji je sinkroniziran Dekkerovim algoritmom.}
\label{overflow}
\end{figure}

\section{Lamportov algoritam - praktični dio}
\paragraph{}
Lamportov je algoritam rješenje problema međusobnog isključivanja između više dretvi. Još se naziva i Lamportov algoritam pekare zbog analogije kojom je najlakše dočarati ideju algoritma. Ako se zamisli pekara da automatom brojeva na ulazu gdje svaki kupac dobiva jedinstveni broj. Taj broj se konstantno povećava svaki put kada ga kupac uzme. Na pultu pekare obješen je globalni brojač koji pokazuje koji kupac se trenutno poslužuje, dok ostali kupci čekaju u redu. Kada pekar završi posluživanje  trenutnog kupca, povećava brojač i sljedeći kupac je na redu. U ovoj analogiji kupci predstavljaju dretve, a pekar predstavlja resurse kojima dretve pristupaju.\\

U svrhu demonstracije algoritma na Android okruženju pokazat će se primjer tijeka rezervacije stolova u nekom restoranu. Sveke sekunde tri dretve slučajno će odabirati jedan od pet stolova. Nakon odabira dretva ulazi u kritični odsječak te ponovo provjerava je li odabrani stol slobodan. Ako jest, označava stol zauzetim i izlazi iz kritičnog odsječka. U oba slučaja, nakon obavljene operacije ispisuje trenutno stanje svih stolova te podatke o obavljenoj rezervaciji na ekran u \textit{TextView}. Taj postupak ponavljat će se sve dok više nema slobodnih stolova.\\

U algoritmu se koristi varijabla \textit{entering} koja označava namjeru dretve za ulazak u kritični odsječak, te varijabla \textit{number} koja redni broj u redu za ulazak.\newpage


Za početak, ostvaruju se metode ulaska i izlaska iz kritičnog odsječka.

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}[
    basicstyle=\footnotesize , %or \small or \footnotesize etc.
]
    private void enterCriticalSection() throws InterruptedException {
        entering[id] = true;
        number[id] = getMaxNumber() + 1;
        entering[id] = false;
        for (int j = 0; j < THREADS_NUMBER; j++) {
            // wait until thread receives its number
            while (entering[j]) {
                Thread.sleep(1000);
            }
            // Wait until all threads with smaller numbers or with the same
            // number, but with higher priority, finish their work:
            while ((number[j] != 0) && (number[j] < number[id] || (number[j] == number[id] && j < id))) {
                Thread.sleep(1000);
            }
        }
    }
    private void exitCriticalSection() {
        number[id] = 0;
	}
\end{lstlisting}
\caption{Lamportov algoritam - Ulazak i izlazak iz kritičnog odsječka.}
\label{overflow}
\end{figure}

Pri ulasku dretve u kritični odsječak, ona prvo dobiva broj za red, nakon čega čeka i obavlja prazan posao sve dok ostale dretve sa manjim brojem ne obave svoj posao do kraja. Pri izlasku dretve iz kritičnog odsječka broj dretve se invalidira tako da ostale koje čekaju u redu mogu nastaviti.\newpage

Nakon toga se radi ostvarenje \textit{Runnable} klase koja predstavlja posao za radnu dretvu.

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}[
    basicstyle=\footnotesize , %or \small or \footnotesize etc.
]
public class LamportRunnable implements Runnable {
    public static volatile boolean[] entering = new boolean[THREADS_NUMBER];
    public static volatile int[] number = new int[THREADS_NUMBER];
    public static volatile int[] tables = new int[TABLES_NUMBER];
	...
    @Override public void run() {
            while (true) {
                Thread.sleep(1000);
                // check if there are free tables
                if (allTablesBooked()) { break; }
                final int wantedTable = (int)(Math.random() * TABLES_NUMBER);
                // update UI thread with data
                 uiPrint("Thread: " + id + ", table picked: " + wantedTable);                
                enterCriticalSection();
                 bookTable(wantedTable);
                exitCriticalSection();
            }
    }
    private void bookTable(final int wantedTable) {
        // if table is free, reserve it
        if (tables[wantedTable] == -1) {
            tables[wantedTable] = id;
            // update UI thread with data
            uiPrint("Thread: " + id + ", table booked: " + wantedTable
                            + ", status: " + getTablesStatus());
        }
        else {
            // update UI thread with data
            uiPrint("Thread: " + id + ", failed booking of table " + wantedTable
                            + ", status: " + getTablesStatus());
        }
	}
\end{lstlisting}
\caption{Ostvarenje \textit{LamportRunnable}.}
\label{overflow}
\end{figure}
\newpage

Na kraju se rade tri radne dretve sa instancama \textit{LamportRunnable} ostvarenja i koje onda počinju birati stolove sa međusobnim isključivanjem sve dok se ne popune svi stolovi. To se pokreće na klik gumba.

\begin{figure}[ht!]
%\includegraphics[width=140mm]{img/android-debug-monitor.png}
\begin{lstlisting}[
    basicstyle=\footnotesize , %or \small or \footnotesize etc.
]
			public void onClick(View view) {
                Thread t1 = new Thread(new LamportRunnable(0, outputTextView));
                t1.start();
                Thread t2 = new Thread(new LamportRunnable(1, outputTextView));
                t2.start();
                Thread t3 = new Thread(new LamportRunnable(2, outputTextView));
                t3.start();
}
\end{lstlisting}
\caption{Lamportov algoritam - Pokretanje radnih dretvi klikom na gumb.}
\label{overflow}
\end{figure}

Nakon klika za pokretanje radnih dretvi one ispisuju svoj posao na ekran kao što  se vidi na sljedećoj slici.

\begin{figure}[ht!]
\centering
\includegraphics[width=65mm]{img/LamportActivity.png}
\caption{Ispis programa koji je sinkroniziran Lamportovim algoritmom.}
\label{overflow}
\end{figure}

\chapter{Zaključak}
\paragraph{}
Iz svega navedenog može se zaključiti da je Android jako složena platforma, zbog čega svaki korak izrade aplikacije za takav sustav predstavlja veliki izazov i odgovornost, jer svaka mala greška može rezultirati jako destruktivno, pa čak i gubljenje krajnjih korisnika što se nikako ne bi smjelo događati. Memorija je ovdje jedan od največih problema i kod razvoja aplikacija jako je krucijalno da se razvijatelji informiraju o Android operacijskom sustavu i njegovim upravljanjem memorijom, procesima i dretvama, te da se upoznaju sa dobrim praksama koje su drugi ljudi stekli iskustvom.

\bibliography{literatura}
\bibliographystyle{fer}
\nocite{android:dev:api:guide}
\nocite{android:dev:best:performance}
\nocite{fer:zemris:os}
\nocite{wiki:dekker}
\nocite{wiki:lamport}
\nocite{wiki:paging}

\begin{sazetak}
U radu pručavaju i opisuju načini ostvarivanja višezadaćnog rada u Android okruženju uz pomoć dretvi i procesa. Navode se i opisuju sikronizacijski mehanizmi, te proučava način upravljanja spremnikom. Uz to daje se uvid u rješenja praktičnog dijela, što uključuje Dekkerov i Lamportov algoritam, te simulacija straničenja uz FIFO strategiju izbacivanja stranica.

\kljucnerijeci{Memorija, Android, dretve, procesi, Dekker, Lamport, sinkronizacija}
\end{sazetak}

% TODO: Navedite naslov na engleskom jeziku.
\engtitle{Multitasking, synchronization and memory management in Android operating system}
\begin{abstract}
This thesis covers multithreading in Android framework focusing on threads and processes. Also it mentions and describes synchronization mechanisms and looks deep into memory management. Furthermore it explains practical solutions which includes Dekker algorithm, Lamport algorithm, and paging simulation with FIFO strategy.

\keywords{Memory, Android, threads, processes, Dekker, Lamport, synchronization}
\end{abstract}

\end{document}
